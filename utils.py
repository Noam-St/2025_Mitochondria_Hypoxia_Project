import pandas as pd
import os
import snoop
import numpy as np
from scipy.stats import mannwhitneyu
import seaborn as sns
import glob, re
import remove_batch_effects as rbe
from matplotlib import pyplot as plt
import consts
from importlib import reload
from statannot import add_stat_annotation
from statannotations.Annotator import Annotator
import scipy.stats as stats
from scipy.stats import norm
from matplotlib.patches import Patch

reload(rbe)
reload(consts)
from matplotlib.lines import Line2D
PATH = os.getcwd()

def genelist(file, mode = 'infer'):
    """
    Generate a dataframe based on a list of genes from a file    
    """
    prefix = os.path.split(file)[-1].replace('.txt', '').replace('.tsv', '')
    if (file.endswith('.txt') and mode == 'infer') or mode == 'txt':
        with open(file) as f:
            genes = f.read().splitlines()
        df = pd.DataFrame({'gene':genes, 'Description' : [prefix for _ in genes]})
    elif (file.endswith('.tsv') and mode == 'infer') or mode == 'tsv':
        df = pd.read_csv(file, delimiter='\t')
        df['Description'] = prefix
    return df

def genelist_on_folder(folder, mode = '.txt'):
    """
    Generate a dataframe based on a list of genes from a folder
    """
    files = os.listdir(rf'{folder}')
    if mode == '.txt':
        files = [f for f in files if f.endswith('.txt')]
    elif mode == '.tsv':
        files = [f for f in files if f.endswith('.tsv')]
    df = pd.DataFrame()
    for i, file in enumerate(files):
        if i == 0:
            df = genelist(os.path.join(folder, file))
        else:
            df = pd.concat([df, genelist(os.path.join(folder, file))])
    return df

def make_volcanoplot(df, cat_col, cat, lfc, pv, geneid, show = False, pval_cutoff = 0.05, lfc_cutoff = 1, figprefix = 'volcano', figtype = 'pdf'):
    """
    Based on a deseq csv, create a volcano plot of all genes within the category
    """
    df_cat = df[df[cat_col] == cat]
    df_cat = df_cat.sort_values(by = pv, ascending = True)
    visuz.GeneExpression.volcano(df = df_cat,
    lfc = lfc,
    pv = pv,
    geneid = geneid,
    gstyle = 2,
    sign_line = True,
    axlabelfontsize = 10,
    geneprefixs = ({k:k for k in df_cat[geneid] if 
                  (df_cat.loc[df_cat[geneid] == k, pv].iloc[0] < pval_cutoff) and\
                  (abs(df_cat.loc[df_cat[geneid] == k, lfc].iloc[0]) > lfc_cutoff)}),
    show = show,
    figprefix = figprefix,
    figtype = figtype)

def generate_2_x_2_conting(
    df,
    row_cat = 'Alter_model',
    comparison_cat = 'strand_switch',
    col_cat_A = 'DSJ',
    col_cat_B = 'SSJ',
    group_factor = 'org',
    cont_factor = 'junc_tpm'):
    """
    Generate a 2x2 chi_squared table for the following factors: significant/non significant and the row_cat.
    The p-values are generated by comparing the cont_factor values between two categories of comparison_cat for each group_factor category.
    """
    AGC_list = []
    non_AGC_list = []
    alpha = 0.05/len(df[group_factor].unique())
    for i in df[group_factor].unique():
        grp_1 = df.loc[(df[comparison_cat] == col_cat_A) & (df[group_factor] == i), cont_factor]
        grp_2 = df.loc[(df[comparison_cat] == col_cat_B) & (df[group_factor] == i), cont_factor]
        AGC = df.loc[df[group_factor] == i, row_cat].iloc[0].squeeze()
        sign = mannwhitneyu(grp_1, grp_2, alternative = 'less').pvalue < alpha
        if AGC:
            AGC_list.append(sign)
        else:
            non_AGC_list.append(sign)
    return np.array([[sum(AGC_list), len(AGC_list) - sum(AGC_list)], [sum(non_AGC_list), len(non_AGC_list) - sum(non_AGC_list)]])

def split_grab(string, delimiter = '>', n = 1):
    """
    Split a string by a delimiter and return the nth element if exists, otherwise return an empty string
    """
    try:
        return string.split(delimiter)[n]
    except IndexError:
        return ''

def prepare_metadata(id_col, label_col, label_list, df, sep = '_'):
    """
    Prepare a metadata df based on EBI's tsv files

    Parameters
    ----------
    id_col : str
        The prefix of the column containing the ids.
    label_col : str
        The prefix of the column containing the labels.
    df : pandas.DataFrame
        The dataframe containing the data.
    sep : str (default: '_')
        The separator used in the metadata file.
    label_list : list
        The list of labels to be used.

    Returns
    -------
    pandas.DataFrame
        The dataframe containing the metadata.
    """
    # Subset only the relevant columns
    metadata = df[[id_col, label_col]].copy()
    # Split the labels into a list based on a given separator
    params = metadata[label_col].apply(lambda x : re.split(sep, x))
    # If the params lists have different lengths, pad them with empty strings in the same position
    params = params.apply(lambda x: x + [np.nan] * (len(label_list) - len(x)))
    # Modify the dataframe
    for i, _ in enumerate(params[0]):
        metadata[label_list[i]] = [j[i] for j in params]
    # Drop the old column
    metadata.drop(label_col, axis = 1, inplace = True)
    return metadata

def prepare_counts(folder, min_read_sum = 1000, keep_symbol = False, keep_suffix = False, suffix_ind = 0):
    """
    Prepare count table for DEseq2 analysis based on a folder of htseq count files

    Parameters
    ----------
    folder : str
        The folder containing the htseq count files.
    min_read_sum : int (default: 1000)
        The minimum read sum to be considered.
    keep_symbol : bool (default: False)
        Whether to keep the symbol column or not.
    suffix : bool (default: False)
        Whether to keep the suffix of the file name or not.

    Returns
    -------
    pandas.DataFrame
        The dataframe containing the counts.
    """
    # Get the files
    paths = glob.glob(os.path.join(folder, '*.txt'))
    c_list = []
    # Iterate over the files in paths
    for i, path in enumerate(paths):
        # Get the suffix
        if not keep_suffix: suffix = os.path.split(path)[-1].split('_')[suffix_ind]
        else: suffix = os.path.split(path)[-1].split('.')[suffix_ind]
        # Load the count dfs
        try:
            count_df = pd.read_csv(path, sep = '\t', header = None)
        except pd.errors.EmptyDataError:
            continue
        # Check col count
        if len(count_df.columns) > 2: # If there are more than 2 columns, assume that there is a symbol column
            count_df.columns = ['id', 'symbol', suffix]
        elif len(count_df.columns) == 2: # If there are only 2 columns, assume that there is no symbol column
            count_df.columns = ['id', suffix]
        else:
            raise ValueError('Invalid column count') # If there are less than 2 columns, raise an error
        # Check the read sum
        if count_df[suffix].sum() < min_read_sum:
            print('{} has too few reads!\n read sum = {}'.format(suffix, count_df[suffix].sum()))
            continue
        # Remove __no_feature etc
        count_df = count_df[~count_df['id'].str.contains('__')]
        # Sort by id
        count_df.sort_values('id', inplace = True)
        # Set ID as index
        count_df.set_index('id', inplace = True)
        if keep_symbol and i == 0:
            c_list.append(count_df['symbol'])
        # Add current countfile to the list
        c_list.append(count_df[suffix])
    # Concatenate the counts
    counts = pd.concat(c_list, axis = 1)
    return counts

def prepare_deseq(path, prefix = 'gene', id_col = 'id', gene_col = 'name', sep = ','):
    """
    Prepare a DEseq2 result file for plotting and add gene annotation information (such as associated OXPHOS complex)

    Parameters
    ----------
    path : str  
        The path to the DEseq2 result file.
    prefix : str (default: 'gene')
        The prefix of the columns in the DEseq2 result file.
    id_col : str (default: 'id')
        The name of the column containing the gene ids.
    gene_col : str (default: 'name')
        The name of the column containing the gene names.
    
    Returns
    -------
    pandas.DataFrame
        The dataframe containing the DEseq2 results.
    """
    if prefix != '': # If there is a name prefix, add it to the column names
        prefix = prefix.replace('\.','') + '.'
    deseq = pd.read_csv(path, sep = sep) # Load the deseq file
    if deseq.shape[1] == 1: # If there is only one column, read first column as index
        deseq = pd.read_csv(path, index_col = 0)
    deseq[f'{prefix}log2FoldChange'] = deseq[f'{prefix}log2FoldChange'].fillna(0) # Fill NaNs with 0
    deseq[f'{prefix}padj'] = deseq[f'{prefix}padj'].fillna(0.99) # Fill NaNs with 0.99
    deseq[f'{prefix}{id_col}'] = deseq[f'{prefix}{id_col}'].str.split('.').str[0] # Remove the transcript.id suffix
    gene_col = prefix + gene_col
    #txtgenes = genelist_on_folder(os.path.join(PATH, 'data', 'genes'), mode = '.txt') # Get the list of gene files
    tsvgenes = genelist_on_folder(os.path.join(PATH, 'data', 'genes'), mode = '.tsv').drop(columns = ['Other_Names', 'Protein_type', 'Subunit_Name', 'Subunit'])
    #deseq = deseq.merge(txtgenes, how = 'left', left_on = gene_col, right_on = 'gene' )
    deseq = deseq.merge(tsvgenes, how = 'left', left_on = gene_col, right_on = 'Name', suffixes = ['_txt', '_tsv']).drop(columns = ['Ensembl_ID', 'Name'])
    #deseq['Complex'] = np.where(deseq['Description_txt'] == 'mtRibosome', 'Ribosome', deseq['Complex'])
    return deseq

def combine_counts_metadata(counts_path, metadata_path, results_path, metadata_id_col = 'run_accession', batch_correction = False, batch_cols = ['replicate']):
    tsvgenes = genelist_on_folder(os.path.join(PATH, 'data', 'genes'), mode = '.tsv').drop(columns = ['Other_Names', 'Protein_type', 'Subunit_Name', 'Subunit', '5.67529814124456', 'From', 'To', 'STC1']).dropna(subset = 'Name')
    if type(counts_path) == str:
        counts = pd.read_csv(counts_path, index_col = 0)
    else:
        counts = counts_path
    # Convert genes to uppercase
    counts.index = counts.index.str.upper()
    # Remove batches if batch_correction is True

    if type(metadata_path) == str:
        metadata = pd.read_csv(metadata_path, index_col = 0)
    else:
        metadata = metadata_path

    if type(results_path) == str:
        results = pd.read_csv(results_path, index_col = 0)
    else:
        results = results_path

    # Convert counts to long format
    counts = counts.reset_index(names = ['gene']).set_index('gene')
    if batch_correction:
        counts, _ = rbe.main(counts, metadata.reset_index(), id_col = 'gene', batch_cols = batch_cols, sample_col = metadata_id_col)
    counts = counts.reset_index()
    counts = counts.melt(id_vars = 'gene', var_name = 'sample', value_name = 'count')
    results = results.reset_index(names = ['gene'])
    # Convert counts to long format and combine with metadata
    counts = counts.merge(metadata, left_on = 'sample', right_on = metadata_id_col, how = 'left')
    # Merge with gene list
    counts = counts.merge(tsvgenes, left_on = 'gene', right_on = 'Name', how = 'left')
    results = results.merge(tsvgenes, left_on = 'gene', right_on = 'Name', how = 'left')
    # Add genome column
    counts['Genome'] = 'NUC'
    results['Genome'] = 'NUC'
    counts.loc[counts['gene'].isin(consts.MT_GENES + consts.MT_GENES_NO_PREFIX), 'Genome'] = 'MT'
    results.loc[results['gene'].isin(consts.MT_GENES + consts.MT_GENES_NO_PREFIX), 'Genome'] = 'MT'
    # Print the number of genes in each genome
    print(counts[counts['count'].notna()].groupby('Genome').agg({'gene':'nunique'}))
    return counts, metadata, results

def combine_counts(counts_path, metadata_path):
    """
    Combine the counts from multiple count_tables into a long-format dataframe with the metadata and info on OXPHOS genes
    """
    counts_path = os.path.join(counts_path, '*.csv')
    metadata_path = os.path.join(metadata_path, '*.csv')
    counts = glob.glob(counts_path)
    metadata_paths= glob.glob(metadata_path)
    count_dfs = []
    metadata_dfs =[]
    for i in metadata_paths:
        metadata_df = pd.read_csv(i)
        metadata_df['dataset'] = os.path.split(i)[-1].split('.')[0]
        metadata_dfs.append(metadata_df)
    metadata_df = pd.concat(metadata_dfs)
    # Fill NAs in run_accession column with the values of sample_accession
    if 'sample_accession' in metadata_df.columns:
        metadata_df['run_accession'] = metadata_df['run_accession'].fillna(metadata_df['sample_accession'])
    if 'Sample_Name' in metadata_df.columns:
        metadata_df['run_accession'] = metadata_df['run_accession'].fillna(metadata_df['Sample_Name'])
    for count_path in counts:
        count_df = pd.read_csv(count_path, index_col = 0)
        count_df = count_df.reset_index().melt(id_vars = 'index', value_name = 'counts', var_name = 'sample').rename(columns = {'index':'gene'})
        count_df = count_df.merge(metadata_df, right_on = 'run_accession', left_on = 'sample', how = 'left').merge(consts.GENELIST_DF, left_on = 'gene', right_on = 'Name', how = 'left')
        # Drop columns that are only na
        count_df = count_df.dropna(axis = 1, how = 'all').rename(columns = {'sample_x':'sample', 'condition': 'treatment', 'Treatment' : 'treatment', 'cell':'cell_type', 'cell_line' : 'cell_type'})
        count_df = count_df.replace(consts.UNIFY_DICT)
        count_df['Genome'] = 'NUC'
        count_df.loc[count_df['gene'].isin(consts.MT_GENES), 'Genome'] = 'MT'
        count_df['dataset'] = os.path.split(count_path)[-1].split('.')[0]
        try: 
            count_df['treatment'] = count_df['treatment'].str.capitalize()
        except KeyError:
            print(f'No treatment column in {count_path}')
        count_df['log2_counts'] = np.log2(count_df['counts'] + 1)
        # Add a cell_type column if it is missing
        if 'cell_type' not in count_df.columns:
            count_df['cell_type'] = os.path.split(count_path)[-1].split('_')[1]
        count_dfs.append(count_df)
    count_df = pd.concat(count_dfs)
    count_df = count_df.dropna(subset = 'treatment')
    # Remove samples where the treatment value is None
    count_df = count_df[count_df['treatment'] != 'None']
    return count_df

def combine_result_files(results_path):
    """
    Combine several result csvs generated by DESeq2 into a single dataframe
    """
    results = glob.glob(os.path.join(results_path, '*.csv'))
    dfs = []
    for file in results:
        df = pd.read_csv(file, index_col = 0)
        df = df.reset_index().rename(columns = {'index': 'Name'})
        name = os.path.split(file)[-1].split('.')[0].replace('res_', '')
        df['dataset'] = name
        df['cell_line'] = name.split('_')[0]
        dfs.append(df)
    results_df = pd.concat(dfs) 
    results_df = results_df.merge(consts.GENELIST_DF, on = 'Name',  how = 'left')
    return results_df
  
def filter_by_peppr(qa_df):
    """
    Filter the input PEPPRO quality metric df based on the ranges defined in consts.PEPPRO_RANGES
    """
    # Get the ranges
    ranges = consts.PEPPRO_RANGES
    # Filter the df
    for col in ranges:
        # Set col type to float
        qa_df[col] = qa_df[col].astype(float)
        qa_df = qa_df[(qa_df[col] >= ranges[col][0]) & (qa_df[col] <= ranges[col][1])]
    return qa_df

def plot_gene_list(
    dfs, prefixes, names, gene_list, gene_list_name, gene_col = 'gene', gene_cat_col = 'Complex', savefig=True, figsize = (5,6), against_bg = True, random_bg = False, gene_name_df = [], sign_only = False, custom_order = []):
    """
    Iterate over all lfc dfs in the dfs list and plot the Log2FoldChange of the genes in the gene_list.
    Mark significant genes in green and insignificant genes in red.
    The gene_list_name will be used as the title of the plot and the plot file name along with the sample name provided in the names list.

    Parameters
    ----------
    dfs : list
        A list of dataframes containing the Log2FoldChange values.
    prefixes : list
        A list of prefixes to be used for each of the columns.
    names : list
        A list of names to be used for each sample.
    gene_list : list
        A list of genes to be plotted.
    gene_list_name : str
        The name of the gene list to be used as the title of the plot and the plot file name.
    
    Returns
    -------
    None
    """
    if prefixes == None:
        prefixes = [''] * len(dfs)
    green_dot = Line2D([0], [0], linestyle = 'none', marker = 'o', color = 'green', alpha = .5)
    red_dot = Line2D([0], [0], linestyle = 'none', marker = 'o', color = 'red', alpha = .5)
    plt.style.use('default')
    # Create a figure with a subplot for each sample
    fig, axs = plt.subplots(len(dfs), 1,figsize = figsize, sharex = True)
    for i, deseq in enumerate(dfs):
        if (type(axs) == list) or (type(axs) == np.ndarray):
            ax = axs[i]
        else:
            ax = axs
        # Get the medians from the background dfs
        deseq = deseq.loc[:, ~deseq.columns.duplicated()]
        hyp = deseq[deseq[gene_col].isin(gene_list)]    
        hyp = hyp.drop_duplicates(subset = gene_col)        
        if len(gene_name_df) > 0:
            hyp[gene_col] = hyp[gene_col].map(gene_name_df.set_index('drosophila')[gene_col])
            hyp['Complex'] = hyp[gene_col].map(gene_name_df.set_index(gene_col)['complex'])
        hyp['significant'] = hyp[f'{prefixes[i]}padj'] < 0.05
        # Replace True with green and False with red
        hyp['significant'] = hyp['significant'].map({True: 'green', False: 'red'})
        if sign_only:
            hyp = hyp[hyp['significant'] == 'green']
        
        hyp['Complex'] =  hyp['Complex'].astype(pd.CategoricalDtype(categories = consts.COMPLEX_ORDER, ordered = True))
        hyp = hyp.sort_values(by = ['Complex', f'{prefixes[i]}log2FoldChange'], ascending = [True, False])
        if custom_order != []:
            hyp = hyp.set_index(gene_col).loc[custom_order].reset_index()
        t = hyp[hyp['significant'] == 'green']
        f = hyp[hyp['significant'] == 'red']
        ax.errorbar(x = hyp[gene_col], y = hyp[f'{prefixes[i]}log2FoldChange'], yerr = hyp[f'{prefixes[i]}lfcSE'], c = 'green', fmt = 'o', ecolor = 'black', alpha = 0)
        ax.errorbar(x = t[gene_col], y = t[f'{prefixes[i]}log2FoldChange'], yerr = t[f'{prefixes[i]}lfcSE'], c = 'green', fmt = 'o', ecolor = 'black',  label = '' if sign_only else 'Significant')
        if not sign_only:
            ax.errorbar(x = f[gene_col], y = f[f'{prefixes[i]}log2FoldChange'], yerr = f[f'{prefixes[i]}lfcSE'], c = 'red', fmt = 'o', ecolor = 'black', label = 'Not significant')
        if against_bg:
            bg = deseq[~deseq[gene_col].isin(gene_list)]
            bg = bg.drop_duplicates(subset = gene_col)
            if sign_only:
                bg = bg[bg[f'{prefixes[i]}padj'] < 0.05]
            if random_bg:
                bg[gene_cat_col] = np.random.choice(bg[gene_cat_col], len(bg), replace = False)
            bg_group = bg.groupby(gene_cat_col).agg({f'{prefixes[i]}log2FoldChange': ['mean', 'std']})
            bg_group.columns = bg_group.columns.droplevel(0)
            bg_group = bg_group.reset_index()
            # Add the median values or each complex to the hyp df
            hyp = hyp.merge(bg_group, on = gene_cat_col, how = 'left')
            # Plot these values
            ax.errorbar(x = hyp[gene_col], y = hyp['mean'], yerr = hyp['std'], c = 'black', fmt = 'o', ecolor = 'black', alpha = 0.3, label = 'nDNA background')
        ax.axhline(y = 0, color = 'black', linestyle = '--', linewidth = .5)
        # despine the top and right spines using plt
        ax.spines['right'].set_visible(False)
        ax.spines['top'].set_visible(False)
        # Flip the x axis 90 degrees
        # Remove grid
        ax.grid(False)
        ax.set_title(f'{names[i]}')
    # Set legend outside the plot
    plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0., fontsize = 8)
    ax.set_ylabel('logFC', fontsize = 10)
    ax.set_xlabel('Genes', fontsize = 10)
    plt.xticks(rotation = 45)
    plt.tight_layout(pad = 0.5)

    if savefig: plt.savefig(os.path.join(PATH, 'figures', f'{names[i]}_{gene_list_name}_fc.png'), dpi = 300, bbox_inches = 'tight')

def plot_expr_gene_list(counts, gene_list, gene_col = 'gene', count_col = 'counts', fact_col = 'treatment', dat_col = None):
    """
    Receive a count df and a list of genes. Plot the normalized expression of gene in list for each treatment in fact_col. Additionally, if the create a subplot for each dataset in dat_col.
    """
    pass

def custom_annot_plot(
        plot = 'boxplot', test_type = 'Mann-Whitney', loc = 'inside', box_pairs = [('DSJ','SSJ')],
        t_format = 'star', xlabel = 'Strand switched', ylabel = 'log(expression)', savefig = False, style = 'default', despine = True, *args, **kwargs):
    """
    Recieve a FacetPlot object, create a boxplot with **kwargs and use add_stat_annotation to perform a statistical test.

    Parameters
    ----------
    test_type :
        (Default value = 'Mann-Whitney') The statistical test to perform
    loc :
        (Default value = 'inside') The location of the annotation
    box_pairs :
        (Default value = [('DSJ') ('SSJ')]) The list of box pairs to perform the statistical test on
    'SSJ')] :
        
    t_format :
        (Default value = 'star') The format of the annotation
    xlabel :
        (Default value = 'Strand switched') The xlabel of the boxplot
    ylabel :
        (Default value = 'log(expression)') The ylabel of the boxplot
    **kwargs : 
        The kwargs to pass to FacetGrid.map_dataframe
    """
    plt.style.use(style)
    plot_dict = {'boxplot': sns.boxplot, 'violinplot': sns.violinplot, 'stripplot': sns.stripplot, 'swarmplot': sns.swarmplot, 'pointplot': sns.pointplot, 'barplot': sns.barplot, 'boxenplot': sns.boxenplot, 'countplot': sns.countplot, 'pointplot': sns.pointplot}
    print(kwargs['data'])
    try: ax = plot_dict[plot](*args, **kwargs)
    except KeyError: print(f'Please select a valid plot type: {list(plot_dict.keys())}')
    # If kwargs['hue'] exists, add the hue to the box_pairs
    if 'hue' in kwargs.keys():
        add_stat_annotation(
        ax, plot = plot, data=kwargs['data'], x=kwargs['x'], y=kwargs['y'], hue = kwargs['hue'],
        box_pairs=box_pairs,
        test = test_type, loc = loc,
        text_format = t_format,
        verbose = 2
        )
    else:
        add_stat_annotation(
        ax, plot = plot, data=kwargs['data'], x=kwargs['x'], y=kwargs['y'],
        box_pairs=box_pairs,
        test = test_type, loc = loc,
        text_format = t_format,
        verbose = 2
        )
    if despine:
        sns.despine(ax = ax, offset = 10, trim = False)
     
def plot_mt_vs_nuc(counts, x = 'treatment', y = 'count', hue = 'Genome', control = 'Normoxia', treatment = 'Hypoxia', nuc_name = 'NUC', mt_name = 'MT', oxphos = True, savefig = '', test = 'Mann-Whitney', test_format = 'star', verbose = 0, stat_loc = 'outside', figsize = (4,4), hyp_time = '24h', hyp_conc = '', species = '', dodge = False, mode = 'pointplot'):
    """
    """
    if oxphos:
        counts = counts[(counts['Complex'].notna()) | (counts['Genome'] == 'MT')]
        # Report how many genes are in each complex and each genome
        print(counts.groupby(['Complex', 'Genome'], dropna=False).agg({'gene':'nunique'}))
    # Calculate z-score
    counts['z-score'] = counts.groupby([hue])[y].transform(lambda x: (x - x.mean()) / x.std())
    _, ax = plt.subplots(figsize = figsize)
    counts = counts.replace({control : 'Normoxia', treatment : 'Hypoxia'})
    control, treatment = 'Normoxia', 'Hypoxia'
    if mode == 'pointplot':
        sns.pointplot(data = counts, x = x, y = 'z-score', hue = hue, hue_order = [nuc_name, mt_name], dodge = dodge, errorbar = 'se', ax = ax, order = [control, treatment], palette=['tab:green', 'tab:red'])
        # Add statistical test
        pairs = [((control, nuc_name), (treatment, nuc_name)), ((control, mt_name), (treatment, mt_name))]
        print(pairs)
        # Set legend outside of plot
        ax.legend(title = hue, bbox_to_anchor=(1.05, 1), loc='upper left')
        add_stat_annotation(ax, data = counts, x = x, y = 'z-score', hue = hue, box_pairs = pairs, test = test, text_format = test_format, loc = stat_loc, verbose = verbose, line_height=0.05)
    elif mode == 'boxplot':

        sns.boxplot(data = counts, x = hue, y = 'z-score', hue = x, hue_order = [control, treatment], ax = ax, palette=['tab:green', 'tab:red'], order = [nuc_name, mt_name])
        pairs = [((nuc_name, control), (nuc_name, treatment)), ((mt_name, control), (mt_name, treatment))]
        # Set legend outside of plot
        ax.legend(title = x, bbox_to_anchor=(1.05, 1), loc='upper left')
        sns.stripplot(data = counts, x = hue, y = 'z-score', hue = x, hue_order = [control, treatment], ax = ax, palette=['grey', 'grey'], order = [nuc_name, mt_name], size = 1.5, alpha = .3, dodge = True, legend=False)

        add_stat_annotation(ax, data = counts, x = hue, y = 'z-score', hue = x, box_pairs = pairs, test = test, text_format = test_format, loc = stat_loc, verbose = verbose, line_height=0.05)
    else:
        print(f'Invalid mode: {mode}\nPlease choose one of the following: pointplot, boxplot')
    # Change the alpha of the error bars
    for line in ax.lines:
        line.set_alpha(0.4)
    # Increase x ticklabel size
    ax.set_xticklabels(ax.get_xticklabels(), fontsize = 12)
    ax.set_xlabel('')
    ax.set_ylabel('Scaled Expression')
    sns.despine()
    # Set title outside the plot
    plt.suptitle(f'{species} {hyp_conc} for {hyp_time}', y = .95)
    plt.tight_layout()
    if savefig != '':
        plt.savefig(os.path.join(PATH, 'Hypoxia_across_evolution', 'figures', f'{species}_{hyp_conc}_{hyp_time}_{nuc_name}_vs_{mt_name}.png'), dpi = 300, bbox_inches = 'tight')

def replace_with_ortho(counts_path, ortho_df, ortho_col, override = True):
    """
    Recieve a counts df of a species, replace the gene names with the orthologous gene names from ortho_df
    """
    counts = pd.read_csv(counts_path, index_col = 0)
    ortho_df = ortho_df.drop_duplicates(subset = ortho_col)[['Gene name', ortho_col]]
    counts = counts.merge(ortho_df, left_index=True, right_on = ortho_col, how = 'left')
    counts['Gene name'] = np.where(counts['Gene name'].isna(), counts[ortho_col], counts['Gene name'])
    counts = counts.set_index('Gene name')
    counts = counts.drop(columns = ortho_col)
    if override:
        counts.to_csv(counts_path)
    else:
        counts.to_csv(counts_path.replace('.csv', '_ortho.csv'))

def mitonuclear_coordination(results_df, mt_gene_thresh = 5, nuc_gene_thresh = 10, dataset_col = 'dataset', padj_thresh = .05, genes = 'both', lfc_col = 'log2FoldChange'):
    """
    Recieve a combined results_df, for each dataset, determine if the mitonuclear expression is coordinated for OXPHOS genes and return three lists, coord list, uncoord list and unassigned list
    
    Parameters
    ----------
    genes : str
        (Default value = 'both') The type of genes to consider, can be 'OXPHOS', 'Ribosome' or 'both'
    """
    # Assign the datasets to coordinated and uncoordinated. In coordinated, the log2FC of significant OXPHOS genes in MT and NUC are in the same direction. In uncoordinated, the log2FC of significant OXPHOS genes in MT and NUC are in the opposite direction.

    results_df_sign = results_df[results_df['padj'] < padj_thresh].copy()
    if genes == 'OXPHOS':
        results_df_sign_oxphos = results_df_sign.loc[(results_df_sign['Complex'].isin(['I', 'II', 'III', 'IV', 'V'])), :].copy()
        N_NUC = consts.N_NUC_OXPHOS_GENES
        N_MT = consts.N_MT_OXPHOS_GENES
    elif genes == 'Ribosome':
        results_df_sign_oxphos = results_df_sign.loc[(results_df_sign['Complex'] == 'Ribosome'), :].copy()
        N_NUC = consts.N_NUC_RIBOSOME_GENES
        N_MT = consts.N_MT_RIBOSOME_GENES
    else: 
        results_df_sign_oxphos = results_df_sign.loc[(results_df_sign['Complex'].notna()) | (results_df_sign['Genome'] == 'MT'), :].copy()
        N_NUC = consts.N_NUC_OXPHOS_GENES + consts.N_NUC_RIBOSOME_GENES
        N_MT = consts.N_MT_OXPHOS_GENES + consts.N_MT_RIBOSOME_GENES
    count = 0
    coordinated = []
    uncoordinated = []
    unassigned = []
    coord_mag_dict = {}
    nuc_mag_dict = {}
    mt_mag_dict = {}
    for dataset in results_df_sign_oxphos.dataset.unique():
        cur_df = results_df_sign_oxphos.loc[results_df_sign_oxphos['dataset'] == dataset, :]
        mt_genes = cur_df.loc[cur_df['Genome'] == 'MT',:].sort_values(by = lfc_col, ascending = False)
        nuc_genes = cur_df.loc[cur_df['Genome'] == 'NUC',:].sort_values(by = lfc_col, ascending = False)
        mt_genes_count = len(mt_genes)
        nuc_genes_count = len(nuc_genes)

        # Calculate the mean of the sign function of log2fc of the genes, this is to determine the mean direction of the genes regardless of the log2fc magnitude
        mt_genes_mean = np.sign(mt_genes[lfc_col]).mean()
        nuc_genes_mean = np.sign(nuc_genes[lfc_col]).mean()
        coord = mt_genes_mean * nuc_genes_mean
        # If any of the genes are lower than threshold, continue
        if mt_genes_count < mt_gene_thresh or nuc_genes_count < nuc_gene_thresh:
            print(f'Not enough {genes} genes in {dataset} (MT: {mt_genes_count}, NUC: {nuc_genes_count}). Skipping...')
            count += 1
            unassigned.append(dataset)
        elif coord > 0:
            coordination = 'Coordinated'
            coordinated.append(dataset)
            # Proportion of genes that have the same sign as coord
        elif coord <= 0:
            coordination = 'Uncoordinated'
            uncoordinated.append(dataset)
            # Proportion of genes that have the same sign as coord
        #old_coord_mag = abs(sum(np.sign(mt_genes['log2FoldChange'])) + sum(np.sign(nuc_genes['log2FoldChange']))/len(mt_genes))
        
        # Magnitude of coordination, defined as the product of the difference between the number of genes with significant positive and negative genes in MT and NUC separately, divided by the total number of genes in MT and NUC 
        n_up_nuc = len(nuc_genes[nuc_genes[lfc_col] > 0])
        n_down_nuc = len(nuc_genes[nuc_genes[lfc_col] < 0])
        n_up_mt = len(mt_genes[mt_genes[lfc_col] > 0])
        n_down_mt = len(mt_genes[mt_genes[lfc_col] < 0])
        nuc_mag = (n_up_nuc - n_down_nuc) / N_NUC
        mt_mag = (n_up_mt - n_down_mt) / N_MT
        # Coordination magnitude calculation: the product of the magnitude of the difference between the number of genes with significant positive and negative genes in MT and NUC separately, divided by the total number of genes in MT and NUC and the sign of the coordination (values need to be negative if the nuc_mag and mt_mag have different signs).
        coord_mag = abs(nuc_mag * mt_mag) * np.sign(nuc_mag * mt_mag)
        nuc_mag_dict[dataset] = abs(nuc_mag)
        mt_mag_dict[dataset] = abs(mt_mag)
        coord_mag_dict[dataset] = coord_mag

    # Print an overall report
    print(f'Out of {len(results_df_sign_oxphos.dataset.unique())} datasets, {count} datasets were skipped due to insufficient genes.')
    print(f'{len(coordinated)} datasets were coordinated, and {len(uncoordinated)} datasets were uncoordinated.')
    print(f'The magnitude of coordination was {np.mean(list(coord_mag_dict.values())):.2f} +- {np.std(list(coord_mag_dict.values())):.2f}')
    return coordinated, uncoordinated, unassigned, coord_mag_dict, nuc_mag_dict, mt_mag_dict

def plot_gene_counts(df, gene, x = 'treatment', y = 'counts', figsize = (3,3), gene_col = 'gene', set_title = '', control = 'Normoxia', treatment = 'Hypoxia', savefig = ''):
    """
    Plot the counts of a gene across treatments
    """
    if len(df[df[gene_col] == gene]) == 0:
        print(f'{gene} does not exist in the dataframe')
        return
    _, ax = plt.subplots(figsize = figsize)
    df = df[df[gene_col] == gene].copy()
    df[x] = df[x].replace({control : 'Normoxia', treatment : 'Hypoxia'})
    conditions = df[x].unique().tolist()
    order = ['Normoxia', 'Hypoxia']
    pairs = [(conditions[i], conditions[j]) for i in range(len(conditions)) for j in range(i+1, len(conditions))]
    # Order control before treatment
    
    sns.barplot(x = x, y = y, data = df, ax = ax, color = 'grey', order = order)
    print(pairs)
    add_stat_annotation(ax, data = df, x = x, y = y, box_pairs = pairs, test = 'Mann-Whitney', text_format = 'star', loc = 'inside', fontsize = 'large', verbose = 2, comparisons_correction = 'bonferroni', order = order)
    if set_title == '':
        ax.set_title(gene)
    else:
        ax.set_title(set_title)
    ax.set_ylabel('Normalized counts', fontsize = 10)
    ax.set_xlabel('')
    # Rotate x ticklabels
    #plt.xticks(rotation = 45)
    sns.despine()
    ax.grid(False)
    plt.tight_layout()
    if savefig != '':
        plt.savefig(os.path.join(PATH, 'Hypoxia_across_evolution', 'figures', f'{savefig}.png'), dpi = 300, bbox_inches = 'tight')

def create_gene_set_matrix(df, path_to_genelist, gene_col = 'gene', dataset_col = 'dataset', mode = 'infer', PROP = 0.5, return_format = 'matrix', threshold = .05):
    """
    Create a gene set matrix dataframe based on a given genelist and return it
    """
    # Load the genelist
    gene_list = genelist(path_to_genelist, mode = mode).rename(columns = {gene_col : 'gene'})
    # Remove duplicate symbols from genelist
    gene_list = gene_list.drop_duplicates(subset = 'gene')
    # Drop the value "gene", if exists and convert to to list
    gene_list = gene_list[gene_list['gene'] != 'gene'].gene.unique().tolist()
    # Upper list
    gene_list = [i.upper() for i in gene_list]
    # Get the number of genes in the list
    gene_df = df[df['gene'].isin(gene_list)].copy()
    #n_genes = len(gene_df.gene.unique())
    n_genes = len(gene_df.gene.unique())

    dataset_dict = {dataset_col : [], 'cell_line' : [], 'Oxygen Concentration' : [], 'up' : [], 'down' : [], 'nonsign' : [], 'total' : [], 'mean_lfc' : [], 'oxphos_coordination_value' : [], 'tfam_lfc' : [], 'lombardi_hindex' : [], 'oxphos_lfc' : [], 'oxphos_mitochondrial_value' : [], 'oxphos_nuclear_value' : []}
    for dataset in gene_df.dataset.unique():
        cur = gene_df[gene_df[dataset_col] == dataset].copy()
        up = round((len(cur[(cur['log2FoldChange'] > 0) & (cur['padj'] < 0.05)])), 2)
        down = round((len(cur[(cur['log2FoldChange'] < 0) & (cur['padj'] < 0.05)])), 2)
        dataset_dict[dataset_col].append(dataset)
        dataset_dict['oxphos_lfc'].append(cur['oxphos_lfc'].iloc[0])
        dataset_dict['cell_line'].append(cur.cell_line.iloc[0])
        dataset_dict['Oxygen Concentration'].append(cur['Oxygen Concentration'].iloc[0])
        dataset_dict['lombardi_hindex'].append(cur['lombardi_hindex'].iloc[0])
        dataset_dict['oxphos_mitochondrial_value'].append(cur['oxphos_mitochondrial_value'].iloc[0])
        dataset_dict['oxphos_nuclear_value'].append(cur['oxphos_nuclear_value'].iloc[0])
        dataset_dict['up'].append(up)
        dataset_dict['down'].append(down)
        dataset_dict['nonsign'].append(100 - up - down)
        dataset_dict['total'].append(n_genes)
        dataset_dict['mean_lfc'].append(cur.loc[: ,'log2FoldChange'].median())
        if 'oxphos_coordination_value' in cur.columns:
            dataset_dict['oxphos_coordination_value'].append(cur['oxphos_coordination_value'].iloc[0])
        else:
            dataset_dict['oxphos_coordination_value'].append(np.nan)
        if 'tfam_lfc' in cur.columns:
            dataset_dict ['tfam_lfc'].append(cur['tfam_lfc'].iloc[0])
        else:
            dataset_dict ['tfam_lfc'].append(np.nan)
    dataset_df = pd.DataFrame(dataset_dict)
    dataset_df['up+down']= dataset_df['up'] + dataset_df['down']
    dataset_df['max_pct'] = 100
    gene_df = gene_df[gene_df['padj'] < threshold] 
    if return_format == 'matrix':
        df_mat = df.pivot_table(index = 'gene', columns = dataset_col, values = 'log2FoldChange')
        df_mat = df_mat.dropna(axis = 1, how = 'all').fillna(0)        # Create a gene matrix
        gene_matrix = df_mat.loc[[i for i in gene_list if i in df_mat.index], :].copy()
        # Remove genes with 0 LFC in PROP of samples
        gene_matrix = gene_matrix.loc[((gene_matrix != 0).mean(axis = 1)) > PROP, :]
        # Remove genes with NA in PROP of samples
        gene_matrix = gene_matrix.loc[gene_matrix.isna().mean(axis = 1) < PROP, :]
        gene_matrix = gene_matrix.loc[gene_matrix.median(axis = 1).sort_values(ascending = False).index, :]
        return gene_matrix, n_genes
    else:
        # Drop duplicates
        gene_df = gene_df.drop_duplicates(subset = ['gene', 'dataset'])        
        gene_df = gene_df.sort_values(by = ['log2FoldChange', 'dataset'], ascending = [True, True])

        return gene_df, dataset_df

def plot_gene_set_per_dataset(df, dataset_df, title = '', figsize = (5.5,7), x = 'log2FoldChange', y = 'cell_line', hue = False, dodge = False, palette = 'Oranges', savefig = '', alpha = .5, size = 2.5, xlab = 'log2FoldChange', legend = True, legend_title = 'Lombardi h-index', sort_by = 'lombardi_hindex', dataset_sort_by = 'up_or_down', linewidth = 1, width = .5, ascending = False, correlate = True, corr_col = 'oxphos_coordination_value', show_total = True, extra_x_cat = False, ylabel = 'Cell Line', relabel = True):
    """
    Plot the log2FoldChange of a gene set per dataset
    """
    if dataset_sort_by == 'up_or_down':
        mean_up = round(dataset_df.up.mean(), 2)
        std_up = round(dataset_df.up.std(), 2)
        mean_down = round(dataset_df.down.mean(), 2)
        std_down = round(dataset_df.down.std(), 2)
        print(f'Mean up: {mean_up}+-{std_up}, mean down: {mean_down}+-{std_down}')
        dataset_sort_by = 'up' if mean_up > mean_down else 'down'
    if extra_x_cat:
        dataset_df = dataset_df.sort_values(by = [extra_x_cat, dataset_sort_by], ascending = [True, ascending])
    else:
        dataset_df = dataset_df.sort_values(by = dataset_sort_by, ascending = ascending)
    order = dataset_df[y].tolist()
    if extra_x_cat:
        _, axes = plt.subplots(1, 3, figsize = figsize, sharey = True, gridspec_kw={'width_ratios': [.45, 2, 1]})
        sns.pointplot(ax = axes[0], x = extra_x_cat, y = y, data = dataset_df, color = 'tab:red', alpha = .5, join = False, linewidth = 10, edgecolor = 'black', order = order)
        axes[0].set_ylabel(ylabel)  

        # Add line at 0.5 and 1
        axes[0].axvline(x = 0.5, linestyle = '--', color = 'red')
        axes[0].axvline(x = 1, linestyle = '--', color = 'orange') 
        # Change ticklabels to percentages
        axes[0].set_xticks([0.5, 1])
        axes[0].set_xticklabels(['0.5%', '1%'], fontsize = 8, rotation = 45)
        axes[0].set_xlim([0, 1.15])
        ax = axes[1]
        ax2 = axes[2]
    else:
        _, axes = plt.subplots(1, 2, figsize = figsize, sharey = True, gridspec_kw={'width_ratios': [2, 1]})
        ax = axes[0]
        ax2 = axes[1]
    # Make the three barplots
    sns.barplot(y = y, x = 'total', data = dataset_df, ax = ax2, color = 'black', label = 'Non-significant', alpha = .5, fill=False, linewidth=1)
    sns.barplot(y = y, x = 'up+down', data = dataset_df, ax = ax2, color = 'tab:green', label = 'Upregulated')
    sns.barplot(y = y, x = 'down', data = dataset_df, ax = ax2, color = 'tab:red', label = 'Downregulated')
    # Add more 
    if hue:
        sns.boxplot(ax = ax, y = y, x = x, hue = hue, dodge = dodge, data = df, orient = 'h', palette = palette, width = width, order = order)
    else:
        sns.boxplot(ax = ax, y = y, x = x, data = df, orient = 'h', color = 'grey', linewidth = linewidth, width = width, order = order)
    # Add stripplot
    sns.stripplot(ax = ax, y = y, x = x, data = df, orient = 'h', color = 'black', alpha = alpha, size = size, order = order)
    # Set line at x=0
    ax.axvline(x = 0, linestyle = '-', color = 'red')

    # Set legend outside of plot
    if hue: ax.legend(title = hue.capitalize().replace('_' , ' '), bbox_to_anchor=(1.68, 0.83), loc='upper left', fontsize = 8)
    else: pass
    if legend: ax2.legend(title = '', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize = 8)
    # Set xlabel 
    if show_total:
        ax2.set_xlabel(f'N genes (total = {dataset_df["total"].max()})', fontsize = 8)
    else:
        ax2.set_xlabel(f'N genes', fontsize = 8)
    # Desine
    sns.despine()
    if extra_x_cat and relabel:
        axes[0].set_yticklabels([dataset_df['cell_line'].iloc[i] for i in range(len(dataset_df))], fontsize = 8)
    # X axis label 
    ax.set_xlabel(xlab)
    # Y axis label
    ax.set_ylabel('')
    ax2.set_ylabel('')
    # Set title
    if correlate:
        corr_value = stats.spearmanr(dataset_df[corr_col], dataset_df['mean_lfc'])
        ax.set_title(f'{title} R={round(corr_value[0], 1)}, P-value={round(corr_value[1], 3)}', fontsize = 8)
        g = sns.lmplot(x = corr_col, y = 'mean_lfc', data = dataset_df, height = 3, aspect = 1, scatter_kws={'alpha':0.5, 'color' : f'tab:green'}, line_kws={'color': f'tab:grey'})
        g.set_axis_labels(corr_col.capitalize().replace('_', ' '), 'log2 Fold Change')
        g.set_titles(title)
    else:
        ax.set_title(title)
    plt.tight_layout()
    if savefig != '':
        plt.savefig(os.path.join(PATH, 'figures', f'{savefig}.svg'), bbox_inches = 'tight')

def plot_mtcp(df, x, y, title, savefig = False, figsize = (3,3), palette = ['tab:green', 'tab:red'], strip_color = 'black', strip_size = 5, strip_jitter = False, strip_alpha = 1, test = "Mann-Whitney", hide_non_significant=False, hue = False):
    """
    """
    df = df.sort_values(x, ascending = False).copy()
    # Infer pairs based on x values
    treats = df[x].unique().tolist()
    pairs = [(treats[i], treats[j]) for i in range(len(treats)) for j in range(i+1, len(treats))]
    _, axes = plt.subplots(1, 1, figsize=figsize)
    sns.barplot(x = x, y = y, data = df, ax = axes,  palette=palette)
    # Add a stripplot
    sns.stripplot(x = x, y = y, data = df, ax = axes, color=strip_color, size=strip_size, jitter = strip_jitter, alpha = strip_alpha)
    # Set title
    axes.set_title(title)
    axes.set_xlabel('')
    axes.set_ylabel('Relative copy number')
    # Replace Hyp with Hypoxia and Norm with Normoxia
    sns.despine()
    annotate = Annotator(x = x, y = y, data = df, ax=axes, pairs = pairs,  verbose = 1, hide_non_significant=hide_non_significant)
    annotate.configure(text_format = 'star', test = test, hide_non_significant=hide_non_significant)
    annotate.apply_and_annotate()
    plt.tight_layout()
    if savefig:
        plt.savefig(os.path.join(PATH, 'figures', f'{savefig}.svg'), bbox_inches = 'tight')



def kl_divergence(mean_1, std_1, mean_2, std_2):
    """Calculates the KL divergence between two normal distributions.

    Args:
        p: A tuple (mean_p, std_dev_p) representing the first normal distribution.
        q: A tuple (mean_q, std_dev_q) representing the second normal distribution.

    Returns:
        The KL divergence between the two distributions.
    """
    # Calculate KL divergence
    kl_div = 0.5 * (np.log(std_2**2 / std_1**2) + (std_1**2 + (mean_1 - mean_2)**2) / std_2**2 - 1)
    print("KL Divergence:", round(kl_div, 2))
    return kl_div

def make_per_dataset_df(df, dataset_col = 'dataset', gene_col = 'gene'):
     """
     Recieve a dataframe of a subset of genes and return a dataframe with the number of up, down and nonsignificant genes per dataset
     """
     dataset_dict = {dataset_col : [], 'cell_line' : [], 'up' : [], 'down' : [], 'nonsign' : [], 'total' : [], 'mean_lfc' : [], 'oxphos_coordination_value' : []}
     for dataset in df[dataset_col].unique():
        cur = df[df[dataset_col] == dataset].copy()
        n_genes = len(cur[gene_col].unique())
        up = round((len(cur[(cur['log2FoldChange'] > 0) & (cur['padj'] < 0.05)]))/ n_genes * 100, 2)
        down = round((len(cur[(cur['log2FoldChange'] < 0) & (cur['padj'] < 0.05)])) / n_genes * 100, 2)
        dataset_dict[dataset_col].append(dataset)
        dataset_dict['cell_line'].append(cur.cell_line.iloc[0])
        dataset_dict['up'].append(up)
        dataset_dict['down'].append(down)
        dataset_dict['nonsign'].append(100 - up - down)
        dataset_dict['total'].append(n_genes)
        dataset_dict['mean_lfc'].append(cur.loc[: ,'log2FoldChange'].median())
        if 'oxphos_coordination_value' in cur.columns:
            dataset_dict['oxphos_coordination_value'].append(cur['oxphos_coordination_value'].iloc[0])
        else:
            dataset_dict['oxphos_coordination_value'].append(np.nan)
     dataset_df = pd.DataFrame(dataset_dict)
     dataset_df['up+down']= dataset_df['up'] + dataset_df['down']
     dataset_df['max_pct'] = 100
     return dataset_df

def make_coord_plots(df, title, save_name, dataset_df_nuc = pd.DataFrame(), dataset_df_mt = pd.DataFrame(), strip_alpha = .05, kind = 'box', dodge = True, s = 3, hue = 'Genome', y = 'dataset_short', x = 'log2FoldChange', figsize = (5, 6), edgecolor = 'grey', linewidth = 1, ylabel = 'Dataset', xlabel = 'Log2 Fold Change', dataset_sort_by = 'up_or_down', extra_x_cat = False, custom_order = False, barplot_x = 'Percentage of genes'):
    """
    Make a plot of the coordinated and uncoordinated genes
    """
    if len(dataset_df_nuc) > 0:
        dataset_df_nuc['Genome'] = 'NUC'
        dataset_df_mt['Genome'] = 'MT'
        dataset_df = dataset_df_nuc.append(dataset_df_mt)
        dataset_df = dataset_df[dataset_df[y].isin(df[y].unique())]
        if extra_x_cat:
            dataset_df_gouped = dataset_df.groupby([y]).agg({'up' : 'mean', 'down' : 'mean', 'mean_lfc' : 'mean', 'cell_line' : 'first', extra_x_cat : 'first'}).reset_index()
        else:
            dataset_df_gouped = dataset_df.groupby([y]).agg({'up' : 'mean', 'down' : 'mean', 'mean_lfc' : 'mean', 'cell_line' : 'first'}).reset_index()
        # Sort dataset df by the order of df
        if dataset_sort_by == 'up_or_down':
            mean_up = np.mean([round(dataset_df_nuc.up.mean()), round(dataset_df_mt.up.mean())])
            std_up = round(dataset_df_nuc.up.std())
            mean_down = np.mean([round(dataset_df_nuc.down.mean()), round(dataset_df_mt.down.mean())])
            std_down = round(dataset_df_nuc.down.std())
            print(f'Mean up: {mean_up} +- {std_up}\nMean down: {mean_down} +- {std_down}')
            dataset_sort_by = 'up' if mean_up > mean_down else 'down'
        if extra_x_cat:
            order = dataset_df_gouped.sort_values([extra_x_cat, dataset_sort_by], ascending = [True, False])[y].tolist()
            _, axes = plt.subplots(1, 3, figsize = figsize, sharey = True, gridspec_kw={'width_ratios': [.45, 2, 1]})
            sns.pointplot(ax = axes[0], x = extra_x_cat, y = y, data = dataset_df_nuc, color = 'tab:red', alpha = .5, join = False, linewidth = 10, edgecolor = 'black', order = order)
            axes[0].set_ylabel(ylabel)  
            # Add line at 0.5 and 1
            axes[0].axvline(x = 0.5, linestyle = '--', color = 'red')
            axes[0].axvline(x = 1, linestyle = '--', color = 'orange') 
            # Change ticklabels to percentages
            axes[0].set_xticks([0.5, 1])
            axes[0].set_xticklabels(['0.5%', '1%'], rotation = 45)
            axes[0].set_xlim([0, 1.1])
            ax = axes[1]
            ax2 = axes[2]
        else:
            order = dataset_df_gouped.sort_values(dataset_sort_by, ascending = False)[y].tolist()
            _, axes = plt.subplots(1, 2, figsize = figsize, sharey = True, gridspec_kw={'width_ratios': [2, 1]})
            ax = axes[0]
            ax2 = axes[1]
        if custom_order:
            order = custom_order
        sns.barplot(ax = ax2, x = 'max_pct', y = y, data = dataset_df,  dodge = True, hue = 'Genome'
        ,palette = ['grey'], linewidth = 0.5, edgecolor = 'black',  hue_order = ['NUC', 'MT'], alpha = 0.5, fill = False, order = order)
        sns.barplot(ax = ax2, x = 'up+down', y = y, data = dataset_df,  dodge = True, hue = 'Genome'
        ,palette = ['tab:green'], linewidth = 0.25, edgecolor = 'black', hue_order = ['NUC', 'MT'], order = order)
        sns.barplot(ax = ax2, x = 'down', y = y, data = dataset_df,  dodge = True,hue = 'Genome'
        , palette = ['tab:red'], linewidth = 0.25, edgecolor = 'black', hue_order = ['NUC', 'MT'], order = order)
        ax2.set_xlabel(barplot_x)
        ax2.set_ylabel('')
        # Drop legend
        ax2.get_legend().remove()
        # Add xlabel at 0, 25, 50, 75 and 100
        ax2.set_xticks([0, 25, 50, 75, 100])
        # At x=100, add text saying NUC and MT
        ax2.text(101, -0.2, 'NUC', verticalalignment = 'center', horizontalalignment = 'left', fontsize = 8)
        ax2.text(101, 0.25, 'MT', verticalalignment = 'center', horizontalalignment = 'left', fontsize = 8)
    else:
        _, ax = plt.subplots(figsize = figsize)
        order = df[y].tolist()
    if kind == 'box':
        sns.boxplot(ax = ax, data = df, hue = hue, x = x, y = y, dodge = dodge,  palette = 'Set2', hue_order = ['NUC', 'MT'], order = order)
        # Remove boxplot legend
        # Add stripplot with low alpha
        sns.stripplot(ax = ax,  data = df,x = x, y = y, hue = hue, dodge = dodge, palette = 'Set2', alpha = strip_alpha, size = s, hue_order = ['NUC', 'MT'], linewidth = .5, edgecolor = 'black', order = order)
        ax.get_legend().remove()

    else:
        sns.boxplot(ax = ax, x = x, y = y,  data = df, palette = ['grey'], order = order)
        # Remove boxplot legend
        sns.stripplot(ax = ax, data = df[df.Genome == 'NUC'], hue = hue, x = x, y = y, dodge = dodge,  palette = 'Set2', alpha = strip_alpha, s = s, hue_order = ['NUC', 'MT'], linewidth = .5, edgecolor = 'black', order = order)
        # Make MT points large
        sns.stripplot(ax = ax, data = df[df.Genome == 'MT'], hue = hue, x = x, y = y, dodge = dodge,  palette = 'Set2', alpha = strip_alpha, s = s*2, hue_order = ['NUC', 'MT'], edgecolor = edgecolor, linewidth=linewidth, order = order) 
        ax.get_legend().remove()
    if extra_x_cat:
        ax.set_ylabel('')
        ax.set_xlabel(xlabel)
        ax.set_title(title)
        # Chance the yticklabels to the values of 'cell_line'
        axes[0].set_yticklabels([dataset_df_nuc[dataset_df_nuc[y] == i].cell_line.iloc[0] for i in order])
    else:
        ax.set(ylabel = ylabel, xlabel = xlabel, title = title)
    # Add a line at x = 0
    ax.axvline(x = 0, color = 'k', linestyle = '--')
    # Move legend out of the plot
    # Set x and y axis labels
    sns.despine()
    plt.tight_layout()

    #Save figure to 'figure_articles' folder
    plt.savefig(os.path.join(PATH, 'figures', f'{save_name}_coordinated_uncoordinated_log2foldchange.svg'), bbox_inches = 'tight')

def plot_gene_clustermap(mat, col_annot = None, col_annot_cols = None, row_annot = None, row_annot_cols = None, col_annot_dicts = [], cmap = 'RdBu_r', figsize = (5.5, 7.5), col_cluster = True, row_cluster = True, xticklabels = False, yticklabels = 'auto', cbar_kws = {'label' : 'LFC'}, dendrogram_ratio = (.1, .1), cbar_pos = (.9, .9, .03, .1), vmin = -2.5, vmax = 2.5,  center = 0, rasterized = True, mask = False, xlabel = 'Dataset', ylabel = 'Gene', savefig = False):
    """
    """
    if row_annot_cols != None and col_annot_cols != None:
        row_annot = row_annot[row_annot_cols]
        col_annot = col_annot[col_annot_cols]
        cm = sns.clustermap(mat, cmap = cmap, figsize = figsize, col_cluster = col_cluster, row_cluster = row_cluster, xticklabels = xticklabels, yticklabels = yticklabels, cbar_kws = cbar_kws, dendrogram_ratio = dendrogram_ratio, cbar_pos = cbar_pos, vmin = vmin, vmax = vmax, center = center, rasterized = rasterized, mask = mask, row_colors = row_annot, col_colors = col_annot)
    elif row_annot_cols != None and col_annot_cols == None:
        row_annot = row_annot[row_annot_cols]
        cm = sns.clustermap(mat, cmap = cmap, figsize = figsize, col_cluster = col_cluster, row_cluster = row_cluster, xticklabels = xticklabels, yticklabels = yticklabels, cbar_kws = cbar_kws, dendrogram_ratio = dendrogram_ratio, cbar_pos = cbar_pos, vmin = vmin, vmax = vmax, center = center, rasterized = rasterized, mask = mask, row_colors = row_annot)
    elif row_annot_cols == None and col_annot_cols != None:
        col_annot = col_annot[col_annot_cols]
        cm = sns.clustermap(mat, cmap = cmap, figsize = figsize, col_cluster = col_cluster, row_cluster = row_cluster, xticklabels = xticklabels, yticklabels = yticklabels, cbar_kws = cbar_kws, dendrogram_ratio = dendrogram_ratio, cbar_pos = cbar_pos, vmin = vmin, vmax = vmax, center = center, rasterized = rasterized, mask = mask, col_colors = col_annot)
    else:
        cm = sns.clustermap(mat, cmap = cmap, figsize = figsize, col_cluster = col_cluster, row_cluster = row_cluster, xticklabels = xticklabels, yticklabels = yticklabels, cbar_kws = cbar_kws, dendrogram_ratio = dendrogram_ratio, cbar_pos = cbar_pos, vmin = vmin, vmax = vmax, center = center, rasterized = rasterized, mask = mask)

    cm.ax_heatmap.set_xlabel(xlabel)
    cm.ax_heatmap.set_ylabel(ylabel)
    legends = []
    for i, v in enumerate(col_annot_dicts):
        handles = [Patch(color = color, label = str(label) + '%' if (type(label) == int) or (type(label) == float) else label) for label, color in v.items()]
        legends.append(plt.legend(handles = handles, title = col_annot_cols[i], loc = 'upper left', bbox_to_anchor = (5, i), fontsize = 8))
        #plt.gca().add_artist(legend)
    
    # Add all legends
    for j, legend in enumerate(legends):
        if j < i:
            plt.gca().add_artist(legend)
    plt.setp(cm.ax_heatmap.yaxis.get_majorticklines(), visible=False)
    plt.setp(cm.ax_heatmap.yaxis.get_majorticklabels(), rotation=0, fontsize = 8)

    if savefig:
        plt.savefig(os.path.join(PATH, 'figures', f'{savefig}'), bbox_inches = 'tight')